// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RENDERDEFINITIONS_RENDERING_H_
#define FLATBUFFERS_GENERATED_RENDERDEFINITIONS_RENDERING_H_

#include "flatbuffers/flatbuffers.h"

namespace rendering {

struct DepthStencilOperation;

struct RenderTargetBlend;

struct DepthStencilState;

struct RasterizerState;

struct BlendState;

struct PipelineState;

struct RenderTarget;

struct RenderPipeline;
struct RenderPipelineBuilder;

/////////////////////////////////////////////////////////////////////////////////
enum class Blend : uint16_t {
  Zero = 0,
  One = 1,
  SrcColor = 2,
  InvSrcColor = 3,
  SrcAlpha = 4,
  InvSrcAlpha = 5,
  DestAlpha = 6,
  InvDestAlpha = 7,
  DestColor = 8,
  InvDestColor = 9,
  SrcAlphaSta = 10,
  BlendFactor = 11,
  InvBlendFactor = 12,
  Src1Color = 13,
  InvSrc1Color = 14,
  Src1Alpha = 15,
  InvSrc1Alpha = 16,
  MIN = Zero,
  MAX = InvSrc1Alpha
};

inline const Blend (&EnumValuesBlend())[17] {
  static const Blend values[] = {
    Blend::Zero,
    Blend::One,
    Blend::SrcColor,
    Blend::InvSrcColor,
    Blend::SrcAlpha,
    Blend::InvSrcAlpha,
    Blend::DestAlpha,
    Blend::InvDestAlpha,
    Blend::DestColor,
    Blend::InvDestColor,
    Blend::SrcAlphaSta,
    Blend::BlendFactor,
    Blend::InvBlendFactor,
    Blend::Src1Color,
    Blend::InvSrc1Color,
    Blend::Src1Alpha,
    Blend::InvSrc1Alpha
  };
  return values;
}

inline const char * const *EnumNamesBlend() {
  static const char * const names[18] = {
    "Zero",
    "One",
    "SrcColor",
    "InvSrcColor",
    "SrcAlpha",
    "InvSrcAlpha",
    "DestAlpha",
    "InvDestAlpha",
    "DestColor",
    "InvDestColor",
    "SrcAlphaSta",
    "BlendFactor",
    "InvBlendFactor",
    "Src1Color",
    "InvSrc1Color",
    "Src1Alpha",
    "InvSrc1Alpha",
    nullptr
  };
  return names;
}

inline const char *EnumNameBlend(Blend e) {
  if (flatbuffers::IsOutRange(e, Blend::Zero, Blend::InvSrc1Alpha)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBlend()[index];
}

enum class BlendOperation : int8_t {
  Add = 0,
  Subtract = 1,
  RevSubtract = 2,
  Min = 3,
  Max = 4,
  MIN = Add,
  MAX = Max
};

inline const BlendOperation (&EnumValuesBlendOperation())[5] {
  static const BlendOperation values[] = {
    BlendOperation::Add,
    BlendOperation::Subtract,
    BlendOperation::RevSubtract,
    BlendOperation::Min,
    BlendOperation::Max
  };
  return values;
}

inline const char * const *EnumNamesBlendOperation() {
  static const char * const names[6] = {
    "Add",
    "Subtract",
    "RevSubtract",
    "Min",
    "Max",
    nullptr
  };
  return names;
}

inline const char *EnumNameBlendOperation(BlendOperation e) {
  if (flatbuffers::IsOutRange(e, BlendOperation::Add, BlendOperation::Max)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBlendOperation()[index];
}

enum class ColorWriteEnabled : uint16_t {
  Red = 0,
  Green = 1,
  Blue = 2,
  Alpha = 3,
  All = 4,
  MIN = Red,
  MAX = All
};

inline const ColorWriteEnabled (&EnumValuesColorWriteEnabled())[5] {
  static const ColorWriteEnabled values[] = {
    ColorWriteEnabled::Red,
    ColorWriteEnabled::Green,
    ColorWriteEnabled::Blue,
    ColorWriteEnabled::Alpha,
    ColorWriteEnabled::All
  };
  return values;
}

inline const char * const *EnumNamesColorWriteEnabled() {
  static const char * const names[6] = {
    "Red",
    "Green",
    "Blue",
    "Alpha",
    "All",
    nullptr
  };
  return names;
}

inline const char *EnumNameColorWriteEnabled(ColorWriteEnabled e) {
  if (flatbuffers::IsOutRange(e, ColorWriteEnabled::Red, ColorWriteEnabled::All)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesColorWriteEnabled()[index];
}

enum class ComparisonFunction : int8_t {
  Never = 0,
  Less = 1,
  Equal = 2,
  LessEqual = 3,
  Greater = 4,
  NotEqual = 5,
  GreaterEqual = 6,
  Always = 7,
  MIN = Never,
  MAX = Always
};

inline const ComparisonFunction (&EnumValuesComparisonFunction())[8] {
  static const ComparisonFunction values[] = {
    ComparisonFunction::Never,
    ComparisonFunction::Less,
    ComparisonFunction::Equal,
    ComparisonFunction::LessEqual,
    ComparisonFunction::Greater,
    ComparisonFunction::NotEqual,
    ComparisonFunction::GreaterEqual,
    ComparisonFunction::Always
  };
  return values;
}

inline const char * const *EnumNamesComparisonFunction() {
  static const char * const names[9] = {
    "Never",
    "Less",
    "Equal",
    "LessEqual",
    "Greater",
    "NotEqual",
    "GreaterEqual",
    "Always",
    nullptr
  };
  return names;
}

inline const char *EnumNameComparisonFunction(ComparisonFunction e) {
  if (flatbuffers::IsOutRange(e, ComparisonFunction::Never, ComparisonFunction::Always)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesComparisonFunction()[index];
}

enum class CullMode : int8_t {
  None = 0,
  Front = 1,
  Back = 2,
  MIN = None,
  MAX = Back
};

inline const CullMode (&EnumValuesCullMode())[3] {
  static const CullMode values[] = {
    CullMode::None,
    CullMode::Front,
    CullMode::Back
  };
  return values;
}

inline const char * const *EnumNamesCullMode() {
  static const char * const names[4] = {
    "None",
    "Front",
    "Back",
    nullptr
  };
  return names;
}

inline const char *EnumNameCullMode(CullMode e) {
  if (flatbuffers::IsOutRange(e, CullMode::None, CullMode::Back)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCullMode()[index];
}

enum class DepthWriteMask : int8_t {
  Zero = 0,
  All = 1,
  MIN = Zero,
  MAX = All
};

inline const DepthWriteMask (&EnumValuesDepthWriteMask())[2] {
  static const DepthWriteMask values[] = {
    DepthWriteMask::Zero,
    DepthWriteMask::All
  };
  return values;
}

inline const char * const *EnumNamesDepthWriteMask() {
  static const char * const names[3] = {
    "Zero",
    "All",
    nullptr
  };
  return names;
}

inline const char *EnumNameDepthWriteMask(DepthWriteMask e) {
  if (flatbuffers::IsOutRange(e, DepthWriteMask::Zero, DepthWriteMask::All)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDepthWriteMask()[index];
}

enum class FillMode : int8_t {
  Wireframe = 0,
  Solid = 1,
  Point = 2,
  MIN = Wireframe,
  MAX = Point
};

inline const FillMode (&EnumValuesFillMode())[3] {
  static const FillMode values[] = {
    FillMode::Wireframe,
    FillMode::Solid,
    FillMode::Point
  };
  return values;
}

inline const char * const *EnumNamesFillMode() {
  static const char * const names[4] = {
    "Wireframe",
    "Solid",
    "Point",
    nullptr
  };
  return names;
}

inline const char *EnumNameFillMode(FillMode e) {
  if (flatbuffers::IsOutRange(e, FillMode::Wireframe, FillMode::Point)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFillMode()[index];
}

enum class FrontClockwise : int8_t {
  True = 0,
  False = 1,
  MIN = True,
  MAX = False
};

inline const FrontClockwise (&EnumValuesFrontClockwise())[2] {
  static const FrontClockwise values[] = {
    FrontClockwise::True,
    FrontClockwise::False
  };
  return values;
}

inline const char * const *EnumNamesFrontClockwise() {
  static const char * const names[3] = {
    "True",
    "False",
    nullptr
  };
  return names;
}

inline const char *EnumNameFrontClockwise(FrontClockwise e) {
  if (flatbuffers::IsOutRange(e, FrontClockwise::True, FrontClockwise::False)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFrontClockwise()[index];
}

enum class StencilOperation : int8_t {
  Keep = 0,
  Zero = 1,
  Replace = 2,
  IncrSat = 3,
  DecrSat = 4,
  Invert = 5,
  Incr = 6,
  Decr = 7,
  MIN = Keep,
  MAX = Decr
};

inline const StencilOperation (&EnumValuesStencilOperation())[8] {
  static const StencilOperation values[] = {
    StencilOperation::Keep,
    StencilOperation::Zero,
    StencilOperation::Replace,
    StencilOperation::IncrSat,
    StencilOperation::DecrSat,
    StencilOperation::Invert,
    StencilOperation::Incr,
    StencilOperation::Decr
  };
  return values;
}

inline const char * const *EnumNamesStencilOperation() {
  static const char * const names[9] = {
    "Keep",
    "Zero",
    "Replace",
    "IncrSat",
    "DecrSat",
    "Invert",
    "Incr",
    "Decr",
    nullptr
  };
  return names;
}

inline const char *EnumNameStencilOperation(StencilOperation e) {
  if (flatbuffers::IsOutRange(e, StencilOperation::Keep, StencilOperation::Decr)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStencilOperation()[index];
}

enum class TextureFormat : uint16_t {
  UNKNOWN = 0,
  R32G32B32A32_TYPELESS = 1,
  R32G32B32A32_FLOAT = 2,
  R32G32B32A32_UINT = 3,
  R32G32B32A32_SINT = 4,
  R32G32B32_TYPELESS = 5,
  R32G32B32_FLOAT = 6,
  R32G32B32_UINT = 7,
  R32G32B32_SINT = 8,
  R16G16B16A16_TYPELESS = 9,
  R16G16B16A16_FLOAT = 10,
  R16G16B16A16_UNORM = 11,
  R16G16B16A16_UINT = 12,
  R16G16B16A16_SNORM = 13,
  R16G16B16A16_SINT = 14,
  R32G32_TYPELESS = 15,
  R32G32_FLOAT = 16,
  R32G32_UINT = 17,
  R32G32_SINT = 18,
  R10G10B10A2_TYPELESS = 19,
  R10G10B10A2_UNORM = 20,
  R10G10B10A2_UINT = 21,
  R11G11B10_FLOAT = 22,
  R8G8B8A8_TYPELESS = 23,
  R8G8B8A8_UNORM = 24,
  R8G8B8A8_UNORM_SRGB = 25,
  R8G8B8A8_UINT = 26,
  R8G8B8A8_SNORM = 27,
  R8G8B8A8_SINT = 28,
  R16G16_TYPELESS = 29,
  R16G16_FLOAT = 30,
  R16G16_UNORM = 31,
  R16G16_UINT = 32,
  R16G16_SNORM = 33,
  R16G16_SINT = 34,
  R32_TYPELESS = 35,
  R32_FLOAT = 36,
  R32_UINT = 37,
  R32_SINT = 38,
  R8G8_TYPELESS = 39,
  R8G8_UNORM = 40,
  R8G8_UINT = 41,
  R8G8_SNORM = 42,
  R8G8_SINT = 43,
  R16_TYPELESS = 44,
  R16_FLOAT = 45,
  R16_UNORM = 46,
  R16_UINT = 47,
  R16_SNORM = 48,
  R16_SINT = 49,
  R8_TYPELESS = 50,
  R8_UNORM = 51,
  R8_UINT = 52,
  R8_SNORM = 53,
  R8_SINT = 54,
  R9G9B9E5_SHAREDEXP = 55,
  D32_FLOAT_S8X24_UINT = 56,
  D32_FLOAT = 57,
  D24_UNORM_S8_UINT = 58,
  D24_UNORM_X8_UINT = 59,
  D16_UNORM = 60,
  S8_UINT = 61,
  BC1_TYPELESS = 62,
  BC1_UNORM = 63,
  BC1_UNORM_SRGB = 64,
  BC2_TYPELESS = 65,
  BC2_UNORM = 66,
  BC2_UNORM_SRGB = 67,
  BC3_TYPELESS = 68,
  BC3_UNORM = 69,
  BC3_UNORM_SRGB = 70,
  BC4_TYPELESS = 71,
  BC4_UNORM = 72,
  BC4_SNORM = 73,
  BC5_TYPELESS = 74,
  BC5_UNORM = 75,
  BC5_SNORM = 76,
  B5G6R5_UNORM = 77,
  B5G5R5A1_UNORM = 78,
  B8G8R8A8_UNORM = 79,
  B8G8R8X8_UNORM = 80,
  R10G10B10_XR_BIAS_A2_UNORM = 81,
  B8G8R8A8_TYPELESS = 82,
  B8G8R8A8_UNORM_SRGB = 83,
  B8G8R8X8_TYPELESS = 84,
  B8G8R8X8_UNORM_SRGB = 85,
  BC6H_TYPELESS = 86,
  BC6H_UF16 = 87,
  BC6H_SF16 = 88,
  BC7_TYPELESS = 89,
  BC7_UNORM = 90,
  BC7_UNORM_SRGB = 91,
  FORCE_UINT = 92,
  MIN = UNKNOWN,
  MAX = FORCE_UINT
};

inline const TextureFormat (&EnumValuesTextureFormat())[93] {
  static const TextureFormat values[] = {
    TextureFormat::UNKNOWN,
    TextureFormat::R32G32B32A32_TYPELESS,
    TextureFormat::R32G32B32A32_FLOAT,
    TextureFormat::R32G32B32A32_UINT,
    TextureFormat::R32G32B32A32_SINT,
    TextureFormat::R32G32B32_TYPELESS,
    TextureFormat::R32G32B32_FLOAT,
    TextureFormat::R32G32B32_UINT,
    TextureFormat::R32G32B32_SINT,
    TextureFormat::R16G16B16A16_TYPELESS,
    TextureFormat::R16G16B16A16_FLOAT,
    TextureFormat::R16G16B16A16_UNORM,
    TextureFormat::R16G16B16A16_UINT,
    TextureFormat::R16G16B16A16_SNORM,
    TextureFormat::R16G16B16A16_SINT,
    TextureFormat::R32G32_TYPELESS,
    TextureFormat::R32G32_FLOAT,
    TextureFormat::R32G32_UINT,
    TextureFormat::R32G32_SINT,
    TextureFormat::R10G10B10A2_TYPELESS,
    TextureFormat::R10G10B10A2_UNORM,
    TextureFormat::R10G10B10A2_UINT,
    TextureFormat::R11G11B10_FLOAT,
    TextureFormat::R8G8B8A8_TYPELESS,
    TextureFormat::R8G8B8A8_UNORM,
    TextureFormat::R8G8B8A8_UNORM_SRGB,
    TextureFormat::R8G8B8A8_UINT,
    TextureFormat::R8G8B8A8_SNORM,
    TextureFormat::R8G8B8A8_SINT,
    TextureFormat::R16G16_TYPELESS,
    TextureFormat::R16G16_FLOAT,
    TextureFormat::R16G16_UNORM,
    TextureFormat::R16G16_UINT,
    TextureFormat::R16G16_SNORM,
    TextureFormat::R16G16_SINT,
    TextureFormat::R32_TYPELESS,
    TextureFormat::R32_FLOAT,
    TextureFormat::R32_UINT,
    TextureFormat::R32_SINT,
    TextureFormat::R8G8_TYPELESS,
    TextureFormat::R8G8_UNORM,
    TextureFormat::R8G8_UINT,
    TextureFormat::R8G8_SNORM,
    TextureFormat::R8G8_SINT,
    TextureFormat::R16_TYPELESS,
    TextureFormat::R16_FLOAT,
    TextureFormat::R16_UNORM,
    TextureFormat::R16_UINT,
    TextureFormat::R16_SNORM,
    TextureFormat::R16_SINT,
    TextureFormat::R8_TYPELESS,
    TextureFormat::R8_UNORM,
    TextureFormat::R8_UINT,
    TextureFormat::R8_SNORM,
    TextureFormat::R8_SINT,
    TextureFormat::R9G9B9E5_SHAREDEXP,
    TextureFormat::D32_FLOAT_S8X24_UINT,
    TextureFormat::D32_FLOAT,
    TextureFormat::D24_UNORM_S8_UINT,
    TextureFormat::D24_UNORM_X8_UINT,
    TextureFormat::D16_UNORM,
    TextureFormat::S8_UINT,
    TextureFormat::BC1_TYPELESS,
    TextureFormat::BC1_UNORM,
    TextureFormat::BC1_UNORM_SRGB,
    TextureFormat::BC2_TYPELESS,
    TextureFormat::BC2_UNORM,
    TextureFormat::BC2_UNORM_SRGB,
    TextureFormat::BC3_TYPELESS,
    TextureFormat::BC3_UNORM,
    TextureFormat::BC3_UNORM_SRGB,
    TextureFormat::BC4_TYPELESS,
    TextureFormat::BC4_UNORM,
    TextureFormat::BC4_SNORM,
    TextureFormat::BC5_TYPELESS,
    TextureFormat::BC5_UNORM,
    TextureFormat::BC5_SNORM,
    TextureFormat::B5G6R5_UNORM,
    TextureFormat::B5G5R5A1_UNORM,
    TextureFormat::B8G8R8A8_UNORM,
    TextureFormat::B8G8R8X8_UNORM,
    TextureFormat::R10G10B10_XR_BIAS_A2_UNORM,
    TextureFormat::B8G8R8A8_TYPELESS,
    TextureFormat::B8G8R8A8_UNORM_SRGB,
    TextureFormat::B8G8R8X8_TYPELESS,
    TextureFormat::B8G8R8X8_UNORM_SRGB,
    TextureFormat::BC6H_TYPELESS,
    TextureFormat::BC6H_UF16,
    TextureFormat::BC6H_SF16,
    TextureFormat::BC7_TYPELESS,
    TextureFormat::BC7_UNORM,
    TextureFormat::BC7_UNORM_SRGB,
    TextureFormat::FORCE_UINT
  };
  return values;
}

inline const char * const *EnumNamesTextureFormat() {
  static const char * const names[94] = {
    "UNKNOWN",
    "R32G32B32A32_TYPELESS",
    "R32G32B32A32_FLOAT",
    "R32G32B32A32_UINT",
    "R32G32B32A32_SINT",
    "R32G32B32_TYPELESS",
    "R32G32B32_FLOAT",
    "R32G32B32_UINT",
    "R32G32B32_SINT",
    "R16G16B16A16_TYPELESS",
    "R16G16B16A16_FLOAT",
    "R16G16B16A16_UNORM",
    "R16G16B16A16_UINT",
    "R16G16B16A16_SNORM",
    "R16G16B16A16_SINT",
    "R32G32_TYPELESS",
    "R32G32_FLOAT",
    "R32G32_UINT",
    "R32G32_SINT",
    "R10G10B10A2_TYPELESS",
    "R10G10B10A2_UNORM",
    "R10G10B10A2_UINT",
    "R11G11B10_FLOAT",
    "R8G8B8A8_TYPELESS",
    "R8G8B8A8_UNORM",
    "R8G8B8A8_UNORM_SRGB",
    "R8G8B8A8_UINT",
    "R8G8B8A8_SNORM",
    "R8G8B8A8_SINT",
    "R16G16_TYPELESS",
    "R16G16_FLOAT",
    "R16G16_UNORM",
    "R16G16_UINT",
    "R16G16_SNORM",
    "R16G16_SINT",
    "R32_TYPELESS",
    "R32_FLOAT",
    "R32_UINT",
    "R32_SINT",
    "R8G8_TYPELESS",
    "R8G8_UNORM",
    "R8G8_UINT",
    "R8G8_SNORM",
    "R8G8_SINT",
    "R16_TYPELESS",
    "R16_FLOAT",
    "R16_UNORM",
    "R16_UINT",
    "R16_SNORM",
    "R16_SINT",
    "R8_TYPELESS",
    "R8_UNORM",
    "R8_UINT",
    "R8_SNORM",
    "R8_SINT",
    "R9G9B9E5_SHAREDEXP",
    "D32_FLOAT_S8X24_UINT",
    "D32_FLOAT",
    "D24_UNORM_S8_UINT",
    "D24_UNORM_X8_UINT",
    "D16_UNORM",
    "S8_UINT",
    "BC1_TYPELESS",
    "BC1_UNORM",
    "BC1_UNORM_SRGB",
    "BC2_TYPELESS",
    "BC2_UNORM",
    "BC2_UNORM_SRGB",
    "BC3_TYPELESS",
    "BC3_UNORM",
    "BC3_UNORM_SRGB",
    "BC4_TYPELESS",
    "BC4_UNORM",
    "BC4_SNORM",
    "BC5_TYPELESS",
    "BC5_UNORM",
    "BC5_SNORM",
    "B5G6R5_UNORM",
    "B5G5R5A1_UNORM",
    "B8G8R8A8_UNORM",
    "B8G8R8X8_UNORM",
    "R10G10B10_XR_BIAS_A2_UNORM",
    "B8G8R8A8_TYPELESS",
    "B8G8R8A8_UNORM_SRGB",
    "B8G8R8X8_TYPELESS",
    "B8G8R8X8_UNORM_SRGB",
    "BC6H_TYPELESS",
    "BC6H_UF16",
    "BC6H_SF16",
    "BC7_TYPELESS",
    "BC7_UNORM",
    "BC7_UNORM_SRGB",
    "FORCE_UINT",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureFormat(TextureFormat e) {
  if (flatbuffers::IsOutRange(e, TextureFormat::UNKNOWN, TextureFormat::FORCE_UINT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextureFormat()[index];
}

enum class TopologyType : int8_t {
  Unknown = 0,
  Point = 1,
  Line = 2,
  Triangle = 3,
  Patch = 4,
  MIN = Unknown,
  MAX = Patch
};

inline const TopologyType (&EnumValuesTopologyType())[5] {
  static const TopologyType values[] = {
    TopologyType::Unknown,
    TopologyType::Point,
    TopologyType::Line,
    TopologyType::Triangle,
    TopologyType::Patch
  };
  return values;
}

inline const char * const *EnumNamesTopologyType() {
  static const char * const names[6] = {
    "Unknown",
    "Point",
    "Line",
    "Triangle",
    "Patch",
    nullptr
  };
  return names;
}

inline const char *EnumNameTopologyType(TopologyType e) {
  if (flatbuffers::IsOutRange(e, TopologyType::Unknown, TopologyType::Patch)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTopologyType()[index];
}

enum class BufferType : int8_t {
  Vertex = 0,
  Index = 1,
  Constant = 2,
  Indirect = 3,
  MIN = Vertex,
  MAX = Indirect
};

inline const BufferType (&EnumValuesBufferType())[4] {
  static const BufferType values[] = {
    BufferType::Vertex,
    BufferType::Index,
    BufferType::Constant,
    BufferType::Indirect
  };
  return values;
}

inline const char * const *EnumNamesBufferType() {
  static const char * const names[5] = {
    "Vertex",
    "Index",
    "Constant",
    "Indirect",
    nullptr
  };
  return names;
}

inline const char *EnumNameBufferType(BufferType e) {
  if (flatbuffers::IsOutRange(e, BufferType::Vertex, BufferType::Indirect)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBufferType()[index];
}

enum class ResourceUsageType : int8_t {
  Immutable = 0,
  Dynamic = 1,
  Stream = 2,
  MIN = Immutable,
  MAX = Stream
};

inline const ResourceUsageType (&EnumValuesResourceUsageType())[3] {
  static const ResourceUsageType values[] = {
    ResourceUsageType::Immutable,
    ResourceUsageType::Dynamic,
    ResourceUsageType::Stream
  };
  return values;
}

inline const char * const *EnumNamesResourceUsageType() {
  static const char * const names[4] = {
    "Immutable",
    "Dynamic",
    "Stream",
    nullptr
  };
  return names;
}

inline const char *EnumNameResourceUsageType(ResourceUsageType e) {
  if (flatbuffers::IsOutRange(e, ResourceUsageType::Immutable, ResourceUsageType::Stream)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResourceUsageType()[index];
}

enum class IndexType : int8_t {
  Uint16 = 0,
  uint32 = 1,
  MIN = Uint16,
  MAX = uint32
};

inline const IndexType (&EnumValuesIndexType())[2] {
  static const IndexType values[] = {
    IndexType::Uint16,
    IndexType::uint32
  };
  return values;
}

inline const char * const *EnumNamesIndexType() {
  static const char * const names[3] = {
    "Uint16",
    "uint32",
    nullptr
  };
  return names;
}

inline const char *EnumNameIndexType(IndexType e) {
  if (flatbuffers::IsOutRange(e, IndexType::Uint16, IndexType::uint32)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIndexType()[index];
}

enum class TextureType : int8_t {
  Texture1D = 0,
  Texture2D = 1,
  Texture3D = 2,
  Texture_1D_Array = 3,
  Texture_2D_Array = 4,
  Texture_Cube_Array = 5,
  MIN = Texture1D,
  MAX = Texture_Cube_Array
};

inline const TextureType (&EnumValuesTextureType())[6] {
  static const TextureType values[] = {
    TextureType::Texture1D,
    TextureType::Texture2D,
    TextureType::Texture3D,
    TextureType::Texture_1D_Array,
    TextureType::Texture_2D_Array,
    TextureType::Texture_Cube_Array
  };
  return values;
}

inline const char * const *EnumNamesTextureType() {
  static const char * const names[7] = {
    "Texture1D",
    "Texture2D",
    "Texture3D",
    "Texture_1D_Array",
    "Texture_2D_Array",
    "Texture_Cube_Array",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureType(TextureType e) {
  if (flatbuffers::IsOutRange(e, TextureType::Texture1D, TextureType::Texture_Cube_Array)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextureType()[index];
}

enum class ShaderStage : int8_t {
  Vertex = 0,
  Fragment = 1,
  Geometry = 2,
  Compute = 3,
  Hull = 4,
  Domain = 5,
  MIN = Vertex,
  MAX = Domain
};

inline const ShaderStage (&EnumValuesShaderStage())[6] {
  static const ShaderStage values[] = {
    ShaderStage::Vertex,
    ShaderStage::Fragment,
    ShaderStage::Geometry,
    ShaderStage::Compute,
    ShaderStage::Hull,
    ShaderStage::Domain
  };
  return values;
}

inline const char * const *EnumNamesShaderStage() {
  static const char * const names[7] = {
    "Vertex",
    "Fragment",
    "Geometry",
    "Compute",
    "Hull",
    "Domain",
    nullptr
  };
  return names;
}

inline const char *EnumNameShaderStage(ShaderStage e) {
  if (flatbuffers::IsOutRange(e, ShaderStage::Vertex, ShaderStage::Domain)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesShaderStage()[index];
}

enum class TextureFilter : int8_t {
  Nearest = 0,
  Linear = 1,
  MIN = Nearest,
  MAX = Linear
};

inline const TextureFilter (&EnumValuesTextureFilter())[2] {
  static const TextureFilter values[] = {
    TextureFilter::Nearest,
    TextureFilter::Linear
  };
  return values;
}

inline const char * const *EnumNamesTextureFilter() {
  static const char * const names[3] = {
    "Nearest",
    "Linear",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureFilter(TextureFilter e) {
  if (flatbuffers::IsOutRange(e, TextureFilter::Nearest, TextureFilter::Linear)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextureFilter()[index];
}

enum class TextureMipFilter : int8_t {
  Nearest = 0,
  Linear = 1,
  MIN = Nearest,
  MAX = Linear
};

inline const TextureMipFilter (&EnumValuesTextureMipFilter())[2] {
  static const TextureMipFilter values[] = {
    TextureMipFilter::Nearest,
    TextureMipFilter::Linear
  };
  return values;
}

inline const char * const *EnumNamesTextureMipFilter() {
  static const char * const names[3] = {
    "Nearest",
    "Linear",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureMipFilter(TextureMipFilter e) {
  if (flatbuffers::IsOutRange(e, TextureMipFilter::Nearest, TextureMipFilter::Linear)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextureMipFilter()[index];
}

enum class TextureAddressMode : int8_t {
  Repeat = 0,
  Mirrored_Repeat = 1,
  Clamp_Edge = 2,
  Clamp_Border = 3,
  MIN = Repeat,
  MAX = Clamp_Border
};

inline const TextureAddressMode (&EnumValuesTextureAddressMode())[4] {
  static const TextureAddressMode values[] = {
    TextureAddressMode::Repeat,
    TextureAddressMode::Mirrored_Repeat,
    TextureAddressMode::Clamp_Edge,
    TextureAddressMode::Clamp_Border
  };
  return values;
}

inline const char * const *EnumNamesTextureAddressMode() {
  static const char * const names[5] = {
    "Repeat",
    "Mirrored_Repeat",
    "Clamp_Edge",
    "Clamp_Border",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureAddressMode(TextureAddressMode e) {
  if (flatbuffers::IsOutRange(e, TextureAddressMode::Repeat, TextureAddressMode::Clamp_Border)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextureAddressMode()[index];
}

enum class VertexComponentFormat : int8_t {
  Float = 0,
  Float2 = 1,
  Float3 = 2,
  Float4 = 3,
  Byte = 4,
  Byte4N = 5,
  UByte = 6,
  UByte4N = 7,
  Short2 = 8,
  Short2N = 9,
  Short4 = 10,
  Short4N = 11,
  MIN = Float,
  MAX = Short4N
};

inline const VertexComponentFormat (&EnumValuesVertexComponentFormat())[12] {
  static const VertexComponentFormat values[] = {
    VertexComponentFormat::Float,
    VertexComponentFormat::Float2,
    VertexComponentFormat::Float3,
    VertexComponentFormat::Float4,
    VertexComponentFormat::Byte,
    VertexComponentFormat::Byte4N,
    VertexComponentFormat::UByte,
    VertexComponentFormat::UByte4N,
    VertexComponentFormat::Short2,
    VertexComponentFormat::Short2N,
    VertexComponentFormat::Short4,
    VertexComponentFormat::Short4N
  };
  return values;
}

inline const char * const *EnumNamesVertexComponentFormat() {
  static const char * const names[13] = {
    "Float",
    "Float2",
    "Float3",
    "Float4",
    "Byte",
    "Byte4N",
    "UByte",
    "UByte4N",
    "Short2",
    "Short2N",
    "Short4",
    "Short4N",
    nullptr
  };
  return names;
}

inline const char *EnumNameVertexComponentFormat(VertexComponentFormat e) {
  if (flatbuffers::IsOutRange(e, VertexComponentFormat::Float, VertexComponentFormat::Short4N)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVertexComponentFormat()[index];
}

enum class VertexInputRate : int8_t {
  PerVertex = 0,
  PerInstance = 1,
  MIN = PerVertex,
  MAX = PerInstance
};

inline const VertexInputRate (&EnumValuesVertexInputRate())[2] {
  static const VertexInputRate values[] = {
    VertexInputRate::PerVertex,
    VertexInputRate::PerInstance
  };
  return values;
}

inline const char * const *EnumNamesVertexInputRate() {
  static const char * const names[3] = {
    "PerVertex",
    "PerInstance",
    nullptr
  };
  return names;
}

inline const char *EnumNameVertexInputRate(VertexInputRate e) {
  if (flatbuffers::IsOutRange(e, VertexInputRate::PerVertex, VertexInputRate::PerInstance)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVertexInputRate()[index];
}

enum class LogicOperation : int8_t {
  Clear = 0,
  Set = 1,
  Copy = 2,
  CopyInverted = 3,
  Noop = 4,
  Invert = 5,
  And = 6,
  Nand = 7,
  Or = 8,
  Nor = 9,
  Xor = 10,
  Equiv = 11,
  AndReverse = 12,
  AndInverted = 13,
  OrReverse = 14,
  OrInverted = 15,
  MIN = Clear,
  MAX = OrInverted
};

inline const LogicOperation (&EnumValuesLogicOperation())[16] {
  static const LogicOperation values[] = {
    LogicOperation::Clear,
    LogicOperation::Set,
    LogicOperation::Copy,
    LogicOperation::CopyInverted,
    LogicOperation::Noop,
    LogicOperation::Invert,
    LogicOperation::And,
    LogicOperation::Nand,
    LogicOperation::Or,
    LogicOperation::Nor,
    LogicOperation::Xor,
    LogicOperation::Equiv,
    LogicOperation::AndReverse,
    LogicOperation::AndInverted,
    LogicOperation::OrReverse,
    LogicOperation::OrInverted
  };
  return values;
}

inline const char * const *EnumNamesLogicOperation() {
  static const char * const names[17] = {
    "Clear",
    "Set",
    "Copy",
    "CopyInverted",
    "Noop",
    "Invert",
    "And",
    "Nand",
    "Or",
    "Nor",
    "Xor",
    "Equiv",
    "AndReverse",
    "AndInverted",
    "OrReverse",
    "OrInverted",
    nullptr
  };
  return names;
}

inline const char *EnumNameLogicOperation(LogicOperation e) {
  if (flatbuffers::IsOutRange(e, LogicOperation::Clear, LogicOperation::OrInverted)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLogicOperation()[index];
}

enum class QueueType : int8_t {
  Graphics = 0,
  Compute = 1,
  CopyTransfer = 2,
  MIN = Graphics,
  MAX = CopyTransfer
};

inline const QueueType (&EnumValuesQueueType())[3] {
  static const QueueType values[] = {
    QueueType::Graphics,
    QueueType::Compute,
    QueueType::CopyTransfer
  };
  return values;
}

inline const char * const *EnumNamesQueueType() {
  static const char * const names[4] = {
    "Graphics",
    "Compute",
    "CopyTransfer",
    nullptr
  };
  return names;
}

inline const char *EnumNameQueueType(QueueType e) {
  if (flatbuffers::IsOutRange(e, QueueType::Graphics, QueueType::CopyTransfer)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQueueType()[index];
}

enum class CommandType : int8_t {
  BindPipeline = 0,
  BindResourceTable = 1,
  BindVertexBuffer = 2,
  BindIndexBuffer = 3,
  Draw = 4,
  DrawIndexed = 5,
  DrawInstanced = 6,
  DrawIndexedInstanced = 7,
  CopyResource = 8,
  MIN = BindPipeline,
  MAX = CopyResource
};

inline const CommandType (&EnumValuesCommandType())[9] {
  static const CommandType values[] = {
    CommandType::BindPipeline,
    CommandType::BindResourceTable,
    CommandType::BindVertexBuffer,
    CommandType::BindIndexBuffer,
    CommandType::Draw,
    CommandType::DrawIndexed,
    CommandType::DrawInstanced,
    CommandType::DrawIndexedInstanced,
    CommandType::CopyResource
  };
  return values;
}

inline const char * const *EnumNamesCommandType() {
  static const char * const names[10] = {
    "BindPipeline",
    "BindResourceTable",
    "BindVertexBuffer",
    "BindIndexBuffer",
    "Draw",
    "DrawIndexed",
    "DrawInstanced",
    "DrawIndexedInstanced",
    "CopyResource",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommandType(CommandType e) {
  if (flatbuffers::IsOutRange(e, CommandType::BindPipeline, CommandType::CopyResource)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCommandType()[index];
}

/////////////////////////////////////////////////////////////////////////////////
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) DepthStencilOperation FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t fail_;
  int8_t depth_fail_;
  int8_t pass_;
  int8_t func_;

 public:
  struct Traits;
  DepthStencilOperation()
      : fail_(0),
        depth_fail_(0),
        pass_(0),
        func_(0) {
  }
  DepthStencilOperation(rendering::StencilOperation _fail, rendering::StencilOperation _depth_fail, rendering::StencilOperation _pass, rendering::ComparisonFunction _func)
      : fail_(flatbuffers::EndianScalar(static_cast<int8_t>(_fail))),
        depth_fail_(flatbuffers::EndianScalar(static_cast<int8_t>(_depth_fail))),
        pass_(flatbuffers::EndianScalar(static_cast<int8_t>(_pass))),
        func_(flatbuffers::EndianScalar(static_cast<int8_t>(_func))) {
  }
  rendering::StencilOperation fail() const {
    return static_cast<rendering::StencilOperation>(flatbuffers::EndianScalar(fail_));
  }
  void mutate_fail(rendering::StencilOperation _fail) {
    flatbuffers::WriteScalar(&fail_, static_cast<int8_t>(_fail));
  }
  rendering::StencilOperation depth_fail() const {
    return static_cast<rendering::StencilOperation>(flatbuffers::EndianScalar(depth_fail_));
  }
  void mutate_depth_fail(rendering::StencilOperation _depth_fail) {
    flatbuffers::WriteScalar(&depth_fail_, static_cast<int8_t>(_depth_fail));
  }
  rendering::StencilOperation pass() const {
    return static_cast<rendering::StencilOperation>(flatbuffers::EndianScalar(pass_));
  }
  void mutate_pass(rendering::StencilOperation _pass) {
    flatbuffers::WriteScalar(&pass_, static_cast<int8_t>(_pass));
  }
  rendering::ComparisonFunction func() const {
    return static_cast<rendering::ComparisonFunction>(flatbuffers::EndianScalar(func_));
  }
  void mutate_func(rendering::ComparisonFunction _func) {
    flatbuffers::WriteScalar(&func_, static_cast<int8_t>(_func));
  }
};
FLATBUFFERS_STRUCT_END(DepthStencilOperation, 4);

struct DepthStencilOperation::Traits {
  using type = DepthStencilOperation;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) RenderTargetBlend FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t blend_enable_;
  int8_t padding0__;
  uint16_t src_blend_;
  uint16_t dst_blend_;
  int8_t blend_operation_;
  int8_t padding1__;
  uint16_t src_blend_alpha_;
  uint16_t dst_blend_alpha_;
  int8_t blend_operation_alpha_;
  int8_t color_write_mask_;

 public:
  struct Traits;
  RenderTargetBlend()
      : blend_enable_(0),
        padding0__(0),
        src_blend_(0),
        dst_blend_(0),
        blend_operation_(0),
        padding1__(0),
        src_blend_alpha_(0),
        dst_blend_alpha_(0),
        blend_operation_alpha_(0),
        color_write_mask_(0) {
    (void)padding0__;
    (void)padding1__;
  }
  RenderTargetBlend(bool _blend_enable, rendering::Blend _src_blend, rendering::Blend _dst_blend, rendering::BlendOperation _blend_operation, rendering::Blend _src_blend_alpha, rendering::Blend _dst_blend_alpha, rendering::BlendOperation _blend_operation_alpha, int8_t _color_write_mask)
      : blend_enable_(flatbuffers::EndianScalar(static_cast<uint8_t>(_blend_enable))),
        padding0__(0),
        src_blend_(flatbuffers::EndianScalar(static_cast<uint16_t>(_src_blend))),
        dst_blend_(flatbuffers::EndianScalar(static_cast<uint16_t>(_dst_blend))),
        blend_operation_(flatbuffers::EndianScalar(static_cast<int8_t>(_blend_operation))),
        padding1__(0),
        src_blend_alpha_(flatbuffers::EndianScalar(static_cast<uint16_t>(_src_blend_alpha))),
        dst_blend_alpha_(flatbuffers::EndianScalar(static_cast<uint16_t>(_dst_blend_alpha))),
        blend_operation_alpha_(flatbuffers::EndianScalar(static_cast<int8_t>(_blend_operation_alpha))),
        color_write_mask_(flatbuffers::EndianScalar(_color_write_mask)) {
    (void)padding0__;
    (void)padding1__;
  }
  bool blend_enable() const {
    return flatbuffers::EndianScalar(blend_enable_) != 0;
  }
  void mutate_blend_enable(bool _blend_enable) {
    flatbuffers::WriteScalar(&blend_enable_, static_cast<uint8_t>(_blend_enable));
  }
  rendering::Blend src_blend() const {
    return static_cast<rendering::Blend>(flatbuffers::EndianScalar(src_blend_));
  }
  void mutate_src_blend(rendering::Blend _src_blend) {
    flatbuffers::WriteScalar(&src_blend_, static_cast<uint16_t>(_src_blend));
  }
  rendering::Blend dst_blend() const {
    return static_cast<rendering::Blend>(flatbuffers::EndianScalar(dst_blend_));
  }
  void mutate_dst_blend(rendering::Blend _dst_blend) {
    flatbuffers::WriteScalar(&dst_blend_, static_cast<uint16_t>(_dst_blend));
  }
  rendering::BlendOperation blend_operation() const {
    return static_cast<rendering::BlendOperation>(flatbuffers::EndianScalar(blend_operation_));
  }
  void mutate_blend_operation(rendering::BlendOperation _blend_operation) {
    flatbuffers::WriteScalar(&blend_operation_, static_cast<int8_t>(_blend_operation));
  }
  rendering::Blend src_blend_alpha() const {
    return static_cast<rendering::Blend>(flatbuffers::EndianScalar(src_blend_alpha_));
  }
  void mutate_src_blend_alpha(rendering::Blend _src_blend_alpha) {
    flatbuffers::WriteScalar(&src_blend_alpha_, static_cast<uint16_t>(_src_blend_alpha));
  }
  rendering::Blend dst_blend_alpha() const {
    return static_cast<rendering::Blend>(flatbuffers::EndianScalar(dst_blend_alpha_));
  }
  void mutate_dst_blend_alpha(rendering::Blend _dst_blend_alpha) {
    flatbuffers::WriteScalar(&dst_blend_alpha_, static_cast<uint16_t>(_dst_blend_alpha));
  }
  rendering::BlendOperation blend_operation_alpha() const {
    return static_cast<rendering::BlendOperation>(flatbuffers::EndianScalar(blend_operation_alpha_));
  }
  void mutate_blend_operation_alpha(rendering::BlendOperation _blend_operation_alpha) {
    flatbuffers::WriteScalar(&blend_operation_alpha_, static_cast<int8_t>(_blend_operation_alpha));
  }
  int8_t color_write_mask() const {
    return flatbuffers::EndianScalar(color_write_mask_);
  }
  void mutate_color_write_mask(int8_t _color_write_mask) {
    flatbuffers::WriteScalar(&color_write_mask_, _color_write_mask);
  }
};
FLATBUFFERS_STRUCT_END(RenderTargetBlend, 14);

struct RenderTargetBlend::Traits {
  using type = RenderTargetBlend;
};

/////////////////////////////////////////////////////////////////////////////////
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) DepthStencilState FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t enable_;
  int8_t depth_function_;
  int8_t depth_write_mask_;
  uint8_t stencil_enable_;
  int8_t stencil_read_mask_;
  int8_t stencil_write_mask_;
  rendering::DepthStencilOperation front_face_;
  rendering::DepthStencilOperation back_face_;

 public:
  struct Traits;
  DepthStencilState()
      : enable_(0),
        depth_function_(0),
        depth_write_mask_(0),
        stencil_enable_(0),
        stencil_read_mask_(0),
        stencil_write_mask_(0),
        front_face_(),
        back_face_() {
  }
  DepthStencilState(bool _enable, rendering::ComparisonFunction _depth_function, rendering::DepthWriteMask _depth_write_mask, bool _stencil_enable, int8_t _stencil_read_mask, int8_t _stencil_write_mask, const rendering::DepthStencilOperation &_front_face, const rendering::DepthStencilOperation &_back_face)
      : enable_(flatbuffers::EndianScalar(static_cast<uint8_t>(_enable))),
        depth_function_(flatbuffers::EndianScalar(static_cast<int8_t>(_depth_function))),
        depth_write_mask_(flatbuffers::EndianScalar(static_cast<int8_t>(_depth_write_mask))),
        stencil_enable_(flatbuffers::EndianScalar(static_cast<uint8_t>(_stencil_enable))),
        stencil_read_mask_(flatbuffers::EndianScalar(_stencil_read_mask)),
        stencil_write_mask_(flatbuffers::EndianScalar(_stencil_write_mask)),
        front_face_(_front_face),
        back_face_(_back_face) {
  }
  bool enable() const {
    return flatbuffers::EndianScalar(enable_) != 0;
  }
  void mutate_enable(bool _enable) {
    flatbuffers::WriteScalar(&enable_, static_cast<uint8_t>(_enable));
  }
  rendering::ComparisonFunction depth_function() const {
    return static_cast<rendering::ComparisonFunction>(flatbuffers::EndianScalar(depth_function_));
  }
  void mutate_depth_function(rendering::ComparisonFunction _depth_function) {
    flatbuffers::WriteScalar(&depth_function_, static_cast<int8_t>(_depth_function));
  }
  rendering::DepthWriteMask depth_write_mask() const {
    return static_cast<rendering::DepthWriteMask>(flatbuffers::EndianScalar(depth_write_mask_));
  }
  void mutate_depth_write_mask(rendering::DepthWriteMask _depth_write_mask) {
    flatbuffers::WriteScalar(&depth_write_mask_, static_cast<int8_t>(_depth_write_mask));
  }
  bool stencil_enable() const {
    return flatbuffers::EndianScalar(stencil_enable_) != 0;
  }
  void mutate_stencil_enable(bool _stencil_enable) {
    flatbuffers::WriteScalar(&stencil_enable_, static_cast<uint8_t>(_stencil_enable));
  }
  int8_t stencil_read_mask() const {
    return flatbuffers::EndianScalar(stencil_read_mask_);
  }
  void mutate_stencil_read_mask(int8_t _stencil_read_mask) {
    flatbuffers::WriteScalar(&stencil_read_mask_, _stencil_read_mask);
  }
  int8_t stencil_write_mask() const {
    return flatbuffers::EndianScalar(stencil_write_mask_);
  }
  void mutate_stencil_write_mask(int8_t _stencil_write_mask) {
    flatbuffers::WriteScalar(&stencil_write_mask_, _stencil_write_mask);
  }
  const rendering::DepthStencilOperation &front_face() const {
    return front_face_;
  }
  rendering::DepthStencilOperation &mutable_front_face() {
    return front_face_;
  }
  const rendering::DepthStencilOperation &back_face() const {
    return back_face_;
  }
  rendering::DepthStencilOperation &mutable_back_face() {
    return back_face_;
  }
};
FLATBUFFERS_STRUCT_END(DepthStencilState, 14);

struct DepthStencilState::Traits {
  using type = DepthStencilState;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RasterizerState FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t fill_mode_;
  int8_t cull_mode_;
  uint8_t front_counter_clockwise_;
  int8_t padding0__;
  int32_t depth_bias_;
  float depth_bias_clamp_;
  float slope_scaled_depth_bias_;
  uint8_t depth_clip_enabled_;
  uint8_t multisample_enabled_;
  uint8_t conservative_;
  int8_t padding1__;

 public:
  struct Traits;
  RasterizerState()
      : fill_mode_(0),
        cull_mode_(0),
        front_counter_clockwise_(0),
        padding0__(0),
        depth_bias_(0),
        depth_bias_clamp_(0),
        slope_scaled_depth_bias_(0),
        depth_clip_enabled_(0),
        multisample_enabled_(0),
        conservative_(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  RasterizerState(rendering::FillMode _fill_mode, rendering::CullMode _cull_mode, bool _front_counter_clockwise, int32_t _depth_bias, float _depth_bias_clamp, float _slope_scaled_depth_bias, bool _depth_clip_enabled, bool _multisample_enabled, bool _conservative)
      : fill_mode_(flatbuffers::EndianScalar(static_cast<int8_t>(_fill_mode))),
        cull_mode_(flatbuffers::EndianScalar(static_cast<int8_t>(_cull_mode))),
        front_counter_clockwise_(flatbuffers::EndianScalar(static_cast<uint8_t>(_front_counter_clockwise))),
        padding0__(0),
        depth_bias_(flatbuffers::EndianScalar(_depth_bias)),
        depth_bias_clamp_(flatbuffers::EndianScalar(_depth_bias_clamp)),
        slope_scaled_depth_bias_(flatbuffers::EndianScalar(_slope_scaled_depth_bias)),
        depth_clip_enabled_(flatbuffers::EndianScalar(static_cast<uint8_t>(_depth_clip_enabled))),
        multisample_enabled_(flatbuffers::EndianScalar(static_cast<uint8_t>(_multisample_enabled))),
        conservative_(flatbuffers::EndianScalar(static_cast<uint8_t>(_conservative))),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  rendering::FillMode fill_mode() const {
    return static_cast<rendering::FillMode>(flatbuffers::EndianScalar(fill_mode_));
  }
  void mutate_fill_mode(rendering::FillMode _fill_mode) {
    flatbuffers::WriteScalar(&fill_mode_, static_cast<int8_t>(_fill_mode));
  }
  rendering::CullMode cull_mode() const {
    return static_cast<rendering::CullMode>(flatbuffers::EndianScalar(cull_mode_));
  }
  void mutate_cull_mode(rendering::CullMode _cull_mode) {
    flatbuffers::WriteScalar(&cull_mode_, static_cast<int8_t>(_cull_mode));
  }
  bool front_counter_clockwise() const {
    return flatbuffers::EndianScalar(front_counter_clockwise_) != 0;
  }
  void mutate_front_counter_clockwise(bool _front_counter_clockwise) {
    flatbuffers::WriteScalar(&front_counter_clockwise_, static_cast<uint8_t>(_front_counter_clockwise));
  }
  int32_t depth_bias() const {
    return flatbuffers::EndianScalar(depth_bias_);
  }
  void mutate_depth_bias(int32_t _depth_bias) {
    flatbuffers::WriteScalar(&depth_bias_, _depth_bias);
  }
  float depth_bias_clamp() const {
    return flatbuffers::EndianScalar(depth_bias_clamp_);
  }
  void mutate_depth_bias_clamp(float _depth_bias_clamp) {
    flatbuffers::WriteScalar(&depth_bias_clamp_, _depth_bias_clamp);
  }
  float slope_scaled_depth_bias() const {
    return flatbuffers::EndianScalar(slope_scaled_depth_bias_);
  }
  void mutate_slope_scaled_depth_bias(float _slope_scaled_depth_bias) {
    flatbuffers::WriteScalar(&slope_scaled_depth_bias_, _slope_scaled_depth_bias);
  }
  bool depth_clip_enabled() const {
    return flatbuffers::EndianScalar(depth_clip_enabled_) != 0;
  }
  void mutate_depth_clip_enabled(bool _depth_clip_enabled) {
    flatbuffers::WriteScalar(&depth_clip_enabled_, static_cast<uint8_t>(_depth_clip_enabled));
  }
  bool multisample_enabled() const {
    return flatbuffers::EndianScalar(multisample_enabled_) != 0;
  }
  void mutate_multisample_enabled(bool _multisample_enabled) {
    flatbuffers::WriteScalar(&multisample_enabled_, static_cast<uint8_t>(_multisample_enabled));
  }
  bool conservative() const {
    return flatbuffers::EndianScalar(conservative_) != 0;
  }
  void mutate_conservative(bool _conservative) {
    flatbuffers::WriteScalar(&conservative_, static_cast<uint8_t>(_conservative));
  }
};
FLATBUFFERS_STRUCT_END(RasterizerState, 20);

struct RasterizerState::Traits {
  using type = RasterizerState;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) BlendState FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t enable_;
  uint8_t separate_blend_;
  rendering::RenderTargetBlend render_target_blend0_;
  rendering::RenderTargetBlend render_target_blend1_;
  rendering::RenderTargetBlend render_target_blend2_;
  rendering::RenderTargetBlend render_target_blend3_;
  rendering::RenderTargetBlend render_target_blend4_;
  rendering::RenderTargetBlend render_target_blend5_;
  rendering::RenderTargetBlend render_target_blend6_;
  rendering::RenderTargetBlend render_target_blend7_;

 public:
  struct Traits;
  BlendState()
      : enable_(0),
        separate_blend_(0),
        render_target_blend0_(),
        render_target_blend1_(),
        render_target_blend2_(),
        render_target_blend3_(),
        render_target_blend4_(),
        render_target_blend5_(),
        render_target_blend6_(),
        render_target_blend7_() {
  }
  BlendState(bool _enable, bool _separate_blend, const rendering::RenderTargetBlend &_render_target_blend0, const rendering::RenderTargetBlend &_render_target_blend1, const rendering::RenderTargetBlend &_render_target_blend2, const rendering::RenderTargetBlend &_render_target_blend3, const rendering::RenderTargetBlend &_render_target_blend4, const rendering::RenderTargetBlend &_render_target_blend5, const rendering::RenderTargetBlend &_render_target_blend6, const rendering::RenderTargetBlend &_render_target_blend7)
      : enable_(flatbuffers::EndianScalar(static_cast<uint8_t>(_enable))),
        separate_blend_(flatbuffers::EndianScalar(static_cast<uint8_t>(_separate_blend))),
        render_target_blend0_(_render_target_blend0),
        render_target_blend1_(_render_target_blend1),
        render_target_blend2_(_render_target_blend2),
        render_target_blend3_(_render_target_blend3),
        render_target_blend4_(_render_target_blend4),
        render_target_blend5_(_render_target_blend5),
        render_target_blend6_(_render_target_blend6),
        render_target_blend7_(_render_target_blend7) {
  }
  bool enable() const {
    return flatbuffers::EndianScalar(enable_) != 0;
  }
  void mutate_enable(bool _enable) {
    flatbuffers::WriteScalar(&enable_, static_cast<uint8_t>(_enable));
  }
  bool separate_blend() const {
    return flatbuffers::EndianScalar(separate_blend_) != 0;
  }
  void mutate_separate_blend(bool _separate_blend) {
    flatbuffers::WriteScalar(&separate_blend_, static_cast<uint8_t>(_separate_blend));
  }
  const rendering::RenderTargetBlend &render_target_blend0() const {
    return render_target_blend0_;
  }
  rendering::RenderTargetBlend &mutable_render_target_blend0() {
    return render_target_blend0_;
  }
  const rendering::RenderTargetBlend &render_target_blend1() const {
    return render_target_blend1_;
  }
  rendering::RenderTargetBlend &mutable_render_target_blend1() {
    return render_target_blend1_;
  }
  const rendering::RenderTargetBlend &render_target_blend2() const {
    return render_target_blend2_;
  }
  rendering::RenderTargetBlend &mutable_render_target_blend2() {
    return render_target_blend2_;
  }
  const rendering::RenderTargetBlend &render_target_blend3() const {
    return render_target_blend3_;
  }
  rendering::RenderTargetBlend &mutable_render_target_blend3() {
    return render_target_blend3_;
  }
  const rendering::RenderTargetBlend &render_target_blend4() const {
    return render_target_blend4_;
  }
  rendering::RenderTargetBlend &mutable_render_target_blend4() {
    return render_target_blend4_;
  }
  const rendering::RenderTargetBlend &render_target_blend5() const {
    return render_target_blend5_;
  }
  rendering::RenderTargetBlend &mutable_render_target_blend5() {
    return render_target_blend5_;
  }
  const rendering::RenderTargetBlend &render_target_blend6() const {
    return render_target_blend6_;
  }
  rendering::RenderTargetBlend &mutable_render_target_blend6() {
    return render_target_blend6_;
  }
  const rendering::RenderTargetBlend &render_target_blend7() const {
    return render_target_blend7_;
  }
  rendering::RenderTargetBlend &mutable_render_target_blend7() {
    return render_target_blend7_;
  }
};
FLATBUFFERS_STRUCT_END(BlendState, 114);

struct BlendState::Traits {
  using type = BlendState;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) PipelineState FLATBUFFERS_FINAL_CLASS {
 private:
  rendering::BlendState blend_state_;
  int16_t padding0__;
  rendering::RasterizerState rasterizer_state_;
  rendering::DepthStencilState depth_stencil_state_;
  int8_t topology_type_;
  int8_t padding1__;

 public:
  struct Traits;
  PipelineState()
      : blend_state_(),
        padding0__(0),
        rasterizer_state_(),
        depth_stencil_state_(),
        topology_type_(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  PipelineState(const rendering::BlendState &_blend_state, const rendering::RasterizerState &_rasterizer_state, const rendering::DepthStencilState &_depth_stencil_state, rendering::TopologyType _topology_type)
      : blend_state_(_blend_state),
        padding0__(0),
        rasterizer_state_(_rasterizer_state),
        depth_stencil_state_(_depth_stencil_state),
        topology_type_(flatbuffers::EndianScalar(static_cast<int8_t>(_topology_type))),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  const rendering::BlendState &blend_state() const {
    return blend_state_;
  }
  rendering::BlendState &mutable_blend_state() {
    return blend_state_;
  }
  const rendering::RasterizerState &rasterizer_state() const {
    return rasterizer_state_;
  }
  rendering::RasterizerState &mutable_rasterizer_state() {
    return rasterizer_state_;
  }
  const rendering::DepthStencilState &depth_stencil_state() const {
    return depth_stencil_state_;
  }
  rendering::DepthStencilState &mutable_depth_stencil_state() {
    return depth_stencil_state_;
  }
  rendering::TopologyType topology_type() const {
    return static_cast<rendering::TopologyType>(flatbuffers::EndianScalar(topology_type_));
  }
  void mutate_topology_type(rendering::TopologyType _topology_type) {
    flatbuffers::WriteScalar(&topology_type_, static_cast<int8_t>(_topology_type));
  }
};
FLATBUFFERS_STRUCT_END(PipelineState, 152);

struct PipelineState::Traits {
  using type = PipelineState;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RenderTarget FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t width_;
  uint16_t height_;
  float scale_x_;
  float scale_y_;
  uint16_t format_;
  int16_t padding0__;

 public:
  struct Traits;
  RenderTarget()
      : width_(0),
        height_(0),
        scale_x_(0),
        scale_y_(0),
        format_(0),
        padding0__(0) {
    (void)padding0__;
  }
  RenderTarget(uint16_t _width, uint16_t _height, float _scale_x, float _scale_y, rendering::TextureFormat _format)
      : width_(flatbuffers::EndianScalar(_width)),
        height_(flatbuffers::EndianScalar(_height)),
        scale_x_(flatbuffers::EndianScalar(_scale_x)),
        scale_y_(flatbuffers::EndianScalar(_scale_y)),
        format_(flatbuffers::EndianScalar(static_cast<uint16_t>(_format))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t width() const {
    return flatbuffers::EndianScalar(width_);
  }
  void mutate_width(uint16_t _width) {
    flatbuffers::WriteScalar(&width_, _width);
  }
  uint16_t height() const {
    return flatbuffers::EndianScalar(height_);
  }
  void mutate_height(uint16_t _height) {
    flatbuffers::WriteScalar(&height_, _height);
  }
  float scale_x() const {
    return flatbuffers::EndianScalar(scale_x_);
  }
  void mutate_scale_x(float _scale_x) {
    flatbuffers::WriteScalar(&scale_x_, _scale_x);
  }
  float scale_y() const {
    return flatbuffers::EndianScalar(scale_y_);
  }
  void mutate_scale_y(float _scale_y) {
    flatbuffers::WriteScalar(&scale_y_, _scale_y);
  }
  rendering::TextureFormat format() const {
    return static_cast<rendering::TextureFormat>(flatbuffers::EndianScalar(format_));
  }
  void mutate_format(rendering::TextureFormat _format) {
    flatbuffers::WriteScalar(&format_, static_cast<uint16_t>(_format));
  }
};
FLATBUFFERS_STRUCT_END(RenderTarget, 16);

struct RenderTarget::Traits {
  using type = RenderTarget;
};

struct RenderPipeline FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RenderPipelineBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4
  };
  const rendering::PipelineState *state() const {
    return GetStruct<const rendering::PipelineState *>(VT_STATE);
  }
  rendering::PipelineState *mutable_state() {
    return GetStruct<rendering::PipelineState *>(VT_STATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<rendering::PipelineState>(verifier, VT_STATE, 4) &&
           verifier.EndTable();
  }
};

struct RenderPipelineBuilder {
  typedef RenderPipeline Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(const rendering::PipelineState *state) {
    fbb_.AddStruct(RenderPipeline::VT_STATE, state);
  }
  explicit RenderPipelineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RenderPipeline> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RenderPipeline>(end);
    return o;
  }
};

inline flatbuffers::Offset<RenderPipeline> CreateRenderPipeline(
    flatbuffers::FlatBufferBuilder &_fbb,
    const rendering::PipelineState *state = nullptr) {
  RenderPipelineBuilder builder_(_fbb);
  builder_.add_state(state);
  return builder_.Finish();
}

struct RenderPipeline::Traits {
  using type = RenderPipeline;
  static auto constexpr Create = CreateRenderPipeline;
};

inline const rendering::RenderPipeline *GetRenderPipeline(const void *buf) {
  return flatbuffers::GetRoot<rendering::RenderPipeline>(buf);
}

inline const rendering::RenderPipeline *GetSizePrefixedRenderPipeline(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<rendering::RenderPipeline>(buf);
}

inline RenderPipeline *GetMutableRenderPipeline(void *buf) {
  return flatbuffers::GetMutableRoot<RenderPipeline>(buf);
}

inline rendering::RenderPipeline *GetMutableSizePrefixedRenderPipeline(void *buf) {
  return flatbuffers::GetMutableSizePrefixedRoot<rendering::RenderPipeline>(buf);
}

inline bool VerifyRenderPipelineBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<rendering::RenderPipeline>(nullptr);
}

inline bool VerifySizePrefixedRenderPipelineBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<rendering::RenderPipeline>(nullptr);
}

inline void FinishRenderPipelineBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<rendering::RenderPipeline> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRenderPipelineBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<rendering::RenderPipeline> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace rendering

#endif  // FLATBUFFERS_GENERATED_RENDERDEFINITIONS_RENDERING_H_
